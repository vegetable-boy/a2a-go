// Copyright 2025 The A2A Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package a2a

import (
	"encoding/gob"
	"encoding/json"
	"fmt"
	"time"

	"github.com/google/uuid"
)

// TaskInfoProvider provides information about the Task.
type TaskInfoProvider interface {
	// TaskInfo returns information about the task.
	TaskInfo() TaskInfo
}

// TaskInfo represents information about the Task and the group of interactions it belongs to.
// Values might be empty which means the TaskInfoProvider is not associated with any tasks.
// An example would be the first user message.
type TaskInfo struct {
	// TaskID is an id of the task.
	TaskID TaskID
	// ContextID is an id of the interactions group the task belong to.
	ContextID string
}

// TaskInfo implements TaskInfoProvider so that the struct can be passed to core type constructor functions.
// For example: a2a.NewMessageForTask(role, a2a.TaskInfo{...}).
func (ti TaskInfo) TaskInfo() TaskInfo {
	return ti
}

// SendMessageResult represents a response for non-streaming message send.
type SendMessageResult interface {
	Event

	isSendMessageResult()
}

func (*Task) isSendMessageResult()    {}
func (*Message) isSendMessageResult() {}

// Event interface is used to represent types that can be sent over a streaming connection.
type Event interface {
	TaskInfoProvider

	isEvent()

	// Meta returns root Metadata of the struct which implements Event.
	Meta() map[string]any
}

func (*Message) isEvent()                 {}
func (*Task) isEvent()                    {}
func (*TaskStatusUpdateEvent) isEvent()   {}
func (*TaskArtifactUpdateEvent) isEvent() {}

// UnmarshalEventJSON unmarshals JSON data into the appropriate Event type based on the 'kind' field.
// The kind field is used as a discriminator to determine which concrete type to unmarshal into.
func UnmarshalEventJSON(data []byte) (Event, error) {
	type typedEvent struct {
		Kind string `json:"kind"`
	}

	var te typedEvent
	if err := json.Unmarshal(data, &te); err != nil {
		return nil, fmt.Errorf("failed to unmarshal event: %w", err)
	}

	switch te.Kind {
	case "message":
		var msg Message
		if err := json.Unmarshal(data, &msg); err != nil {
			return nil, fmt.Errorf("failed to unmarshal Message event: %w", err)
		}
		return &msg, nil
	case "task":
		var task Task
		if err := json.Unmarshal(data, &task); err != nil {
			return nil, fmt.Errorf("failed to unmarshal Task event: %w", err)
		}
		return &task, nil
	case "status-update":
		var statusUpdate TaskStatusUpdateEvent
		if err := json.Unmarshal(data, &statusUpdate); err != nil {
			return nil, fmt.Errorf("failed to unmarshal TaskStatusUpdateEvent: %w", err)
		}
		return &statusUpdate, nil
	case "artifact-update":
		var artifactUpdate TaskArtifactUpdateEvent
		if err := json.Unmarshal(data, &artifactUpdate); err != nil {
			return nil, fmt.Errorf("failed to unmarshal TaskArtifactUpdateEvent: %w", err)
		}
		return &artifactUpdate, nil
	default:
		return nil, fmt.Errorf("unknown event kind: %s", te.Kind)
	}
}

// MessageRole represents a set of possible values that identify the message sender.
type MessageRole string

const (
	MessageRoleUnspecified MessageRole = ""
	MessageRoleAgent       MessageRole = "agent"
	MessageRoleUser        MessageRole = "user"
)

// NewMessageID generates a new random message identifier.
func NewMessageID() string {
	return newUUIDString()
}

var _ Event = (*Message)(nil)

// Message represents a single message in the conversation between a user and an agent.
type Message struct {
	// ID is a unique identifier for the message, typically a UUID, generated by the sender.
	ID string `json:"messageId" yaml:"messageId" mapstructure:"messageId"`

	// ContextID is the context identifier for this message, used to group related interactions.
	// An empty string means the message doesn't reference any context.
	ContextID string `json:"contextId,omitempty" yaml:"contextId,omitempty" mapstructure:"contextId,omitempty"`

	// Extensions are the URIs of extensions that are relevant to this message.
	Extensions []string `json:"extensions,omitempty" yaml:"extensions,omitempty" mapstructure:"extensions,omitempty"`

	// Metadata is an optional metadata for extensions. The key is an extension-specific identifier.
	Metadata map[string]any `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`

	// Parts is an array of content parts that form the message body. A message can be
	// composed of multiple parts of different types (e.g., text and files).
	Parts ContentParts `json:"parts" yaml:"parts" mapstructure:"parts"`

	// ReferenceTasks is a list of other task IDs that this message references for additional context.
	ReferenceTasks []TaskID `json:"referenceTaskIds,omitempty" yaml:"referenceTaskIds,omitempty" mapstructure:"referenceTaskIds,omitempty"`

	// Role identifies the sender of the message.
	Role MessageRole `json:"role" yaml:"role" mapstructure:"role"`

	// TaskID is the identifier of the task this message is part of. Can be omitted for the
	// first message of a new task.
	// An empty string means the message doesn't reference any Task.
	TaskID TaskID `json:"taskId,omitempty" yaml:"taskId,omitempty" mapstructure:"taskId,omitempty"`
}

func (m Message) MarshalJSON() ([]byte, error) {
	type wrapped Message
	type withKind struct {
		Kind string `json:"kind"`
		wrapped
	}
	return json.Marshal(withKind{Kind: "message", wrapped: wrapped(m)})
}

// NewMessage creates a new message with a random identifier.
func NewMessage(role MessageRole, parts ...Part) *Message {
	return &Message{
		ID:    NewMessageID(),
		Role:  role,
		Parts: parts,
	}
}

// NewMessageForTask creates a new message with a random identifier that references the provided Task.
func NewMessageForTask(role MessageRole, infoProvider TaskInfoProvider, parts ...Part) *Message {
	taskInfo := infoProvider.TaskInfo()
	return &Message{
		ID:        NewMessageID(),
		Role:      role,
		TaskID:    taskInfo.TaskID,
		ContextID: taskInfo.ContextID,
		Parts:     parts,
	}
}

func (m *Message) Meta() map[string]any {
	return m.Metadata
}

func (m *Message) TaskInfo() TaskInfo {
	return TaskInfo{TaskID: m.TaskID, ContextID: m.ContextID}
}

// TaskID is a unique identifier for the task, generated by the server for a new task.
type TaskID string

// NewTaskID generates a new random task identifier.
func NewTaskID() TaskID {
	return TaskID(newUUIDString())
}

// NewContextID generates a new random context identifier.
func NewContextID() string {
	return newUUIDString()
}

// TastState defines a set of possible task states.
type TaskState string

const (
	// TaskStateUnspecified represents a missing TaskState value.
	TaskStateUnspecified TaskState = ""
	// TaskStateAuthRequired means the task requires authentication to proceed.
	TaskStateAuthRequired TaskState = "auth-required"
	// TaskStateCanceled means the task has been canceled by the user.
	TaskStateCanceled TaskState = "canceled"
	// TaskStateCompleted means the task has been successfully completed.
	TaskStateCompleted TaskState = "completed"
	// TaskStateFailed means the task failed due to an error during execution.
	TaskStateFailed TaskState = "failed"
	// TaskStateInputRequired means the task is paused and waiting for input from the user.
	TaskStateInputRequired TaskState = "input-required"
	// TaskStateRejected means the task was rejected by the agent and was not started.
	TaskStateRejected TaskState = "rejected"
	// TaskStateSubmitted means the task has been submitted and is awaiting execution.
	TaskStateSubmitted TaskState = "submitted"
	// TaskStateUnknown means the task is in an unknown or indeterminate state.
	TaskStateUnknown TaskState = "unknown"
	// TaskStateWorking means The agent is actively working on the task.
	TaskStateWorking TaskState = "working"
)

// Terminal returns true for states in which a Task becomes immutable, i.e. no further
// changes to the Task are permitted.
func (ts TaskState) Terminal() bool {
	return ts == TaskStateCompleted ||
		ts == TaskStateCanceled ||
		ts == TaskStateFailed ||
		ts == TaskStateRejected
}

var _ Event = (*Task)(nil)

// Task represents a single, stateful operation or conversation between a client and an agent.
type Task struct {
	// ID is a unique identifier for the task, generated by the server for a new task.
	ID TaskID `json:"id" yaml:"id" mapstructure:"id"`

	// Artifacts is a collection of artifacts generated by the agent during the execution of the task.
	Artifacts []*Artifact `json:"artifacts,omitempty" yaml:"artifacts,omitempty" mapstructure:"artifacts,omitempty"`

	// ContextID is a server-generated identifier for maintaining context across multiple related
	// tasks or interactions. Required to be non empty.
	ContextID string `json:"contextId" yaml:"contextId" mapstructure:"contextId"`

	// History is an array of messages exchanged during the task, representing the conversation history.
	History []*Message `json:"history,omitempty" yaml:"history,omitempty" mapstructure:"history,omitempty"`

	// Metadata is an optional metadata for extensions. The key is an extension-specific identifier.
	Metadata map[string]any `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`

	// Status is the current status of the task, including its state and a descriptive message.
	Status TaskStatus `json:"status" yaml:"status" mapstructure:"status"`
}

// NewSubmittedTask is a utility for creating a Task in submitted state from the initial Message.
// New values are generated for task and context id when they are missing.
func NewSubmittedTask(infoProvider TaskInfoProvider, initialMessage *Message) *Task {
	taskInfo := infoProvider.TaskInfo()
	taskID := taskInfo.TaskID
	if taskID == "" {
		taskID = NewTaskID()
	}
	contextID := taskInfo.ContextID
	if contextID == "" {
		contextID = NewContextID()
	}
	return &Task{
		ID:        taskID,
		ContextID: contextID,
		Status:    TaskStatus{State: TaskStateSubmitted},
		History:   []*Message{initialMessage},
	}
}

func (t Task) MarshalJSON() ([]byte, error) {
	type wrapped Task
	type withKind struct {
		Kind string `json:"kind"`
		wrapped
	}
	return json.Marshal(withKind{Kind: "task", wrapped: wrapped(t)})
}

// TaskStatus represents the status of a task at a specific point in time.
type TaskStatus struct {
	// Message is an optional, human-readable message providing more details about the current status.
	Message *Message `json:"message,omitempty" yaml:"message,omitempty" mapstructure:"message,omitempty"`

	// State is the current state of the task's lifecycle.
	State TaskState `json:"state" yaml:"state" mapstructure:"state"`

	// Timestamp is a datetime indicating when this status was recorded.
	Timestamp *time.Time `json:"timestamp,omitempty" yaml:"timestamp,omitempty" mapstructure:"timestamp,omitempty"`
}

func (m *Task) Meta() map[string]any {
	return m.Metadata
}

func (m *Task) TaskInfo() TaskInfo {
	return TaskInfo{TaskID: m.ID, ContextID: m.ContextID}
}

// ArtifactID is a unique identifier for the artifact within the scope of the task.
type ArtifactID string

// NewArtifactID generates a new random artifact identifier.
func NewArtifactID() ArtifactID {
	return ArtifactID(newUUIDString())
}

// Artifact represents a file, data structure, or other resource generated by an agent during a task.
type Artifact struct {
	// ID is a unique identifier for the artifact within the scope of the task.
	ID ArtifactID `json:"artifactId" yaml:"artifactId" mapstructure:"artifactId"`

	// Description is an optional, human-readable description of the artifact.
	Description string `json:"description,omitempty" yaml:"description,omitempty" mapstructure:"description,omitempty"`

	// Extensions are the URIs of extensions that are relevant to this artifact.
	Extensions []string `json:"extensions,omitempty" yaml:"extensions,omitempty" mapstructure:"extensions,omitempty"`

	// Metadata is an optional metadata for extensions. The key is an extension-specific identifier.
	Metadata map[string]any `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`

	// Name is an optional, human-readable name for the artifact.
	Name string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Parts is an array of content parts that make up the artifact.
	Parts ContentParts `json:"parts" yaml:"parts" mapstructure:"parts"`
}

var _ Event = (*TaskArtifactUpdateEvent)(nil)

// TaskArtifactUpdateEvent is an event sent by the agent to notify the client that an artifact has been
// generated or updated. This is typically used in streaming models.
type TaskArtifactUpdateEvent struct {
	// Append indicates if the content of this artifact should be appended to a previously sent
	// artifact with the same ID.
	Append bool `json:"append,omitempty" yaml:"append,omitempty" mapstructure:"append,omitempty"`

	// Artifact is the artifact that was generated or updated.
	Artifact *Artifact `json:"artifact" yaml:"artifact" mapstructure:"artifact"`

	// ContextID is the context ID associated with the task. Required to be non-empty.
	ContextID string `json:"contextId" yaml:"contextId" mapstructure:"contextId"`

	// LastChunk indicates if this is the final chunk of the artifact.
	LastChunk bool `json:"lastChunk,omitempty" yaml:"lastChunk,omitempty" mapstructure:"lastChunk,omitempty"`

	// TaskID is the ID of the task this artifact belongs to.
	TaskID TaskID `json:"taskId" yaml:"taskId" mapstructure:"taskId"`

	// Metadata is an optional metadata for extensions.
	Metadata map[string]any `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`
}

func (e TaskArtifactUpdateEvent) MarshalJSON() ([]byte, error) {
	type wrapped TaskArtifactUpdateEvent
	type withKind struct {
		Kind string `json:"kind"`
		wrapped
	}
	return json.Marshal(withKind{Kind: "artifact-update", wrapped: wrapped(e)})
}

func (a *TaskArtifactUpdateEvent) Meta() map[string]any {
	return a.Metadata
}

func (m *TaskArtifactUpdateEvent) TaskInfo() TaskInfo {
	return TaskInfo{TaskID: m.TaskID, ContextID: m.ContextID}
}

// NewArtifactEvent create a TaskArtifactUpdateEvent for an Artifact with a random ID.
func NewArtifactEvent(infoProvider TaskInfoProvider, parts ...Part) *TaskArtifactUpdateEvent {
	taskInfo := infoProvider.TaskInfo()
	return &TaskArtifactUpdateEvent{
		ContextID: taskInfo.ContextID,
		TaskID:    taskInfo.TaskID,
		Artifact: &Artifact{
			ID:    NewArtifactID(),
			Parts: parts,
		},
	}
}

// NewArtifactUpdateEvent creates a TaskArtifactUpdateEvent that represents an update of the artifact with the provided ID.
func NewArtifactUpdateEvent(infoProvider TaskInfoProvider, id ArtifactID, parts ...Part) *TaskArtifactUpdateEvent {
	taskInfo := infoProvider.TaskInfo()
	return &TaskArtifactUpdateEvent{
		ContextID: taskInfo.ContextID,
		TaskID:    taskInfo.TaskID,
		Append:    true,
		Artifact: &Artifact{
			ID:    id,
			Parts: parts,
		},
	}
}

var _ Event = (*TaskStatusUpdateEvent)(nil)

// TaskStatusUpdateEvent is an event sent by the agent to notify the client of a change in a task's status.
// This is typically used in streaming or subscription models.
type TaskStatusUpdateEvent struct {
	// ContextID is the context ID associated with the task. Required to be non-empty.
	ContextID string `json:"contextId" yaml:"contextId" mapstructure:"contextId"`

	// Final indicates if this is the final event in the stream for this interaction.
	Final bool `json:"final" yaml:"final" mapstructure:"final"`

	// Status is the new status of the task.
	Status TaskStatus `json:"status" yaml:"status" mapstructure:"status"`

	// TaskID is the ID of the task that was updated.
	TaskID TaskID `json:"taskId" yaml:"taskId" mapstructure:"taskId"`

	// Metadata is an optional metadata for extensions.
	Metadata map[string]any `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`
}

func (e TaskStatusUpdateEvent) MarshalJSON() ([]byte, error) {
	type wrapped TaskStatusUpdateEvent
	type withKind struct {
		Kind string `json:"kind"`
		wrapped
	}
	return json.Marshal(withKind{Kind: "status-update", wrapped: wrapped(e)})
}

// NewStatusUpdateEvent creates a TaskStatusUpdateEvent that references the provided Task.
func NewStatusUpdateEvent(infoProvider TaskInfoProvider, state TaskState, msg *Message) *TaskStatusUpdateEvent {
	now := time.Now()
	taskInfo := infoProvider.TaskInfo()
	return &TaskStatusUpdateEvent{
		ContextID: taskInfo.ContextID,
		TaskID:    taskInfo.TaskID,
		Status: TaskStatus{
			State:     state,
			Message:   msg,
			Timestamp: &now,
		},
	}
}

func (a *TaskStatusUpdateEvent) Meta() map[string]any {
	return a.Metadata
}

func (m *TaskStatusUpdateEvent) TaskInfo() TaskInfo {
	return TaskInfo{TaskID: m.TaskID, ContextID: m.ContextID}
}

// ContentParts is an array of content parts that form the message body or an artifact.
type ContentParts []Part

func (j ContentParts) MarshalJSON() ([]byte, error) {
	if j == nil {
		return []byte("[]"), nil
	}
	return json.Marshal([]Part(j))
}

func (j *ContentParts) UnmarshalJSON(b []byte) error {
	type typedPart struct {
		Kind string `json:"kind"`
	}

	var arr []json.RawMessage
	if err := json.Unmarshal(b, &arr); err != nil {
		return err
	}

	result := make([]Part, len(arr))
	for i, rawMsg := range arr {
		var tp typedPart
		if err := json.Unmarshal(rawMsg, &tp); err != nil {
			return err
		}
		switch tp.Kind {
		case "text":
			var part TextPart
			if err := json.Unmarshal(rawMsg, &part); err != nil {
				return err
			}
			result[i] = part
		case "data":
			var part DataPart
			if err := json.Unmarshal(rawMsg, &part); err != nil {
				return err
			}
			result[i] = part
		case "file":
			var part FilePart
			if err := json.Unmarshal(rawMsg, &part); err != nil {
				return err
			}
			result[i] = part
		default:
			return fmt.Errorf("unknown part kind %s", tp.Kind)
		}
	}

	*j = result
	return nil
}

// Part is a discriminated union representing a part of a message or artifact, which can
// be text, a file, or structured data.
type Part interface {
	isPart()

	Meta() map[string]any
}

func (TextPart) isPart() {}
func (FilePart) isPart() {}
func (DataPart) isPart() {}

func init() {
	gob.Register(TextPart{})
	gob.Register(FilePart{})
	gob.Register(DataPart{})
}

// TextPart represents a text segment within a message or artifact.
type TextPart struct {
	// Text is the string content of the text part.
	Text string `json:"text" yaml:"text" mapstructure:"text"`

	// Metadata is an optional metadata associated with the part.
	Metadata map[string]any `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`
}

func (p TextPart) Meta() map[string]any {
	return p.Metadata
}

func (p TextPart) MarshalJSON() ([]byte, error) {
	type wrapped TextPart
	type withKind struct {
		Kind string `json:"kind"`
		wrapped
	}
	return json.Marshal(withKind{Kind: "text", wrapped: wrapped(p)})
}

// DataPart represents a structured data segment (e.g., JSON) within a message or artifact.
type DataPart struct {
	// Data is the structured data content.
	Data map[string]any `json:"data" yaml:"data" mapstructure:"data"`

	// Metadata is an optional metadata associated with the part.
	Metadata map[string]any `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`
}

func (p DataPart) Meta() map[string]any {
	return p.Metadata
}

func (p DataPart) MarshalJSON() ([]byte, error) {
	type wrapped DataPart
	type withKind struct {
		Kind string `json:"kind"`
		wrapped
	}
	return json.Marshal(withKind{Kind: "data", wrapped: wrapped(p)})
}

// FilePart represents a file segment within a message or artifact. The file content can be
// provided either directly as bytes or as a URI.
type FilePart struct {
	// File the file content, represented as either a URI or as base64-encoded bytes.
	File FilePartContent `json:"file" yaml:"file" mapstructure:"file"`

	// Metadata is an optional metadata associated with the part.
	Metadata map[string]any `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`
}

func (p FilePart) Meta() map[string]any {
	return p.Metadata
}

func (p FilePart) MarshalJSON() ([]byte, error) {
	type wrapped FilePart
	type withKind struct {
		Kind string `json:"kind"`
		wrapped
	}
	return json.Marshal(withKind{Kind: "file", wrapped: wrapped(p)})
}

func (p *FilePart) UnmarshalJSON(b []byte) error {
	type filePartContentUnion struct {
		FileMeta
		URI   string `json:"uri"`
		Bytes string `json:"bytes"`
	}
	type partJSON struct {
		File     filePartContentUnion `json:"file"`
		Metadata map[string]any       `json:"metadata"`
	}
	var decoded partJSON
	if err := json.Unmarshal(b, &decoded); err != nil {
		return err
	}

	if len(decoded.File.Bytes) == 0 && len(decoded.File.URI) == 0 {
		return fmt.Errorf("invalid file part: either Bytes or URI must be set")
	}
	if len(decoded.File.Bytes) > 0 && len(decoded.File.URI) > 0 {
		return fmt.Errorf("invalid file part: Bytes and URI cannot be set at the same time")
	}

	res := FilePart{Metadata: decoded.Metadata}
	if len(decoded.File.Bytes) > 0 {
		res.File = FileBytes{Bytes: decoded.File.Bytes, FileMeta: decoded.File.FileMeta}
	} else {
		res.File = FileURI{URI: decoded.File.URI, FileMeta: decoded.File.FileMeta}
	}

	*p = res
	return nil
}

// FilePartContent is a discriminated union of possible file part payloads.
type FilePartContent interface{ isFilePartContent() }

func (FileBytes) isFilePartContent() {}
func (FileURI) isFilePartContent()   {}

func init() {
	gob.Register(FileBytes{})
	gob.Register(FileURI{})
}

// FileMeta represents file metadata of a file part.
type FileMeta struct {
	// MimeType is an optinal MIME type of the file (e.g., "application/pdf").
	MimeType string `json:"mimeType,omitempty" yaml:"mimeType,omitempty" mapstructure:"mimeType,omitempty"`

	// Name is an optional name for the file (e.g., "document.pdf").
	Name string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`
}

// FileBytes represents a file with its content provided directly as a base64-encoded string.
type FileBytes struct {
	FileMeta
	// Bytes is the base64-encoded content of the file.
	Bytes string `json:"bytes" yaml:"bytes" mapstructure:"bytes"`
}

// FileURI represents a file with its content located at a specific URI.
type FileURI struct {
	FileMeta
	// URI is a URI pointing to the file's content.
	URI string `json:"uri" yaml:"uri" mapstructure:"uri"`
}

// Requests

// TaskIDParams defines parameters containing a task ID, used for simple task operations.
type TaskIDParams struct {
	// TaskID is the unique identifier of the task.
	ID TaskID `json:"id" yaml:"id" mapstructure:"id"`

	// Metadata is an optional metadata associated with the request.
	Metadata map[string]any `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`
}

// TaskQueryParams defines parameters for querying a task, with an option to limit history length.
type TaskQueryParams struct {
	// HistoryLength is the number of most recent messages from the task's history to retrieve.
	HistoryLength *int `json:"historyLength,omitempty" yaml:"historyLength,omitempty" mapstructure:"historyLength,omitempty"`

	// ID is the unique identifier of the task.
	ID TaskID `json:"id" yaml:"id" mapstructure:"id"`

	// Metadata is an optional metadata associated with the request.
	Metadata map[string]any `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`
}

// MessageSendConfig defines configuration options for a `message/send` or `message/stream` request.
type MessageSendConfig struct {
	// AcceptedOutputModes is a list of output MIME types the client is prepared to accept in the response.
	AcceptedOutputModes []string `json:"acceptedOutputModes,omitempty" yaml:"acceptedOutputModes,omitempty" mapstructure:"acceptedOutputModes,omitempty"`

	// Blocking indicates if the client will wait for the task to complete. The server may reject
	// this if the task is long-running. Server might choose to default to true.
	Blocking *bool `json:"blocking,omitempty" yaml:"blocking,omitempty" mapstructure:"blocking,omitempty"`

	// HistoryLength is the number of most recent messages from the task's history to retrieve in the response.
	HistoryLength *int `json:"historyLength,omitempty" yaml:"historyLength,omitempty" mapstructure:"historyLength,omitempty"`

	// PushConfig is configuration for the agent to send push notifications for updates after the initial response.
	PushConfig *PushConfig `json:"pushNotificationConfig,omitempty" yaml:"pushNotificationConfig,omitempty" mapstructure:"pushNotificationConfig,omitempty"`
}

// MessageSendParams defines the parameters for a request to send a message to an agent. This can be used
// to create a new task, continue an existing one, or restart a task.
type MessageSendParams struct {
	// Config is an optional configuration for the send request.
	Config *MessageSendConfig `json:"configuration,omitempty" yaml:"configuration,omitempty" mapstructure:"configuration,omitempty"`

	// Message is the message object being sent to the agent.
	Message *Message `json:"message" yaml:"message" mapstructure:"message"`

	// Metadata is an optional metadata for extensions.
	Metadata map[string]any `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`
}

// Time-based UUID generally improves index update performance if ID field is indexed in a persistent store.
func newUUIDString() string {
	return uuid.Must(uuid.NewV7()).String()
}

// ListTasksRequest defines the parameters for a request to list tasks.
type ListTasksRequest struct {
	// ContextID is the ID of the context to list tasks for.
	ContextID string `json:"context_id,omitempty" yaml:"context_id,omitempty" mapstructure:"context_id,omitempty"`

	// Status is the current state of the tasks to list.
	Status TaskState `json:"status,omitempty" yaml:"status,omitempty" mapstructure:"status,omitempty"`

	// PageSize is the maximum number of tasks to return in the response.
	// Must be between 1 and 100. If not set, the default value is 50.
	PageSize int `json:"page_size,omitempty" yaml:"page_size,omitempty" mapstructure:"page_size,omitempty"`

	// PageToken is the token for retrieving the next page of results.
	PageToken string `json:"page_token,omitempty" yaml:"page_token,omitempty" mapstructure:"page_token,omitempty"`

	// HistoryLength is the number of most recent messages from the task's history to retrieve in the response.
	HistoryLength int `json:"history_length,omitempty" yaml:"history_length,omitempty" mapstructure:"history_length,omitempty"`

	// LastUpdatedAfter is the time to list tasks updated after.
	LastUpdatedAfter *time.Time `json:"last_updated_after,omitempty" yaml:"last_updated_after,omitempty" mapstructure:"last_updated_after,omitempty"`

	// IncludeArtifacts is whether to include artifacts in the response.
	IncludeArtifacts bool `json:"include_artifacts,omitempty" yaml:"include_artifacts,omitempty" mapstructure:"include_artifacts,omitempty"`
}

// ListTasksResponse defines the response for a request to tasks/list.
type ListTasksResponse struct {
	// Tasks is the list of tasks matching the specified criteria.
	Tasks []*Task `json:"tasks,omitempty" yaml:"tasks,omitempty" mapstructure:"tasks,omitempty"`

	// TotalSize is the total number of tasks available (before pagination).
	TotalSize int `json:"total_size,omitempty" yaml:"total_size,omitempty" mapstructure:"total_size,omitempty"`

	// PageSize is the maximum number of tasks returned in the response.
	PageSize int `json:"page_size,omitempty" yaml:"page_size,omitempty" mapstructure:"page_size,omitempty"`

	// NextPageToken is the token for retrieving the next page of results.
	// Empty string if no more results.
	NextPageToken string `json:"next_page_token,omitempty" yaml:"next_page_token,omitempty" mapstructure:"next_page_token,omitempty"`
}
